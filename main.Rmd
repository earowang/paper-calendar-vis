---
author:
  - name: Earo Wang
    affiliation: Monash University
    address: >
      Department of Econometrics and Business Statistics,
      Monash University, VIC 3800
      Australia
    email: \email{earo.wang@monash.edu}
  - name: Di Cook
    affiliation: Monash Univeristy
    address: >
      Department of Econometrics and Business Statistics,
      Monash University, VIC 3800
      Australia
    email: \email{dicook@monash.edu}
  - name: Rob J Hyndman
    affiliation: Monash Univeristy
    address: >
      Department of Econometrics and Business Statistics,
      Monash University, VIC 3800
      Australia
    email: \email{rob.hyndman@monash.edu}
title:
  formatted: "Calendar-based graphics for visualising people's daily schedules"
  plain: "Calendar-based graphics for visualising people's daily schedules"
abstract: >
  It is often challenging to visualise people's daily schedules as the data are of multiple seasons and of long length. One such example is Melbourne pedestrian sensor data which are collected at hourly interval and at a number of locations. Owing to human-related activities, the primary depiction of the data features multiple temopral scales such as time of day, day of week, day of year. We introduce the \code{frame\_calendar} function that provides a method for rearranging such kind of data in a calendar-based format and accomplishing visualisation with the grammar of graphics, and describe its construction in detail. We provide some examples to demonstrate its usage by applying to the pedetrian data.
keywords:
  # at least one keyword must be supplied
  formatted: [calendar-based visualisation, temporal-context data]
  plain:     [calendar-based visualisation, temporal-context data]
preamble: >
  \usepackage{amsmath}
output: 
  rticles::jss_article:
  citation_package: biblatex
bibliography: ["references.bib", "packages.bib"]
---

```{r initial, echo = FALSE, cache = FALSE, include = FALSE}
library(knitr)
opts_chunk$set(
  warning = FALSE, message = FALSE, echo = FALSE,
  fig.path = 'figure/', cache.path = 'cache/', fig.align = 'center', 
  fig.show = 'hold', cache = TRUE, external = TRUE, dev = "svglite"
)
read_chunk('src/main.R')
```

```{r load}
```

# Introduction

This work was originally motivated by studying foot traffic in the city of Melbourne [@ped]. There have been 43 installed sensors counting pedestrians every hour across downtown Melbourne until recently. The dataset can shed lights into understanding people's daily schedules, or assisting administration and business planning. (FIGURE ?: weekday at multiple sensors) Figure (?) lends itself to a number of issues that make exploratory data visualisation challenging in many temporal-context applications involving human behaviours: 

1. Variations primarily result from multiple time scales including time of day, day of week, and day of year (such as public holiday and recurred events).
2. Since the data are often collected at daily frequency or a time scale more frequent than daily, they typically involve a large number of observations spanning over a long time period.
3. Measurements of a single type are made at multiple locations at a given time point, which creates a need in comparing and contrasting between locations.

Calendar-based graphics turn out to be a useful tool in unfolding human-related activities in temporal context (cite). For example, @VanWijkCluster1999 developed a calendar view of heatmap to represent the number of employees in the work place over a year, where colours indicate different clusters derived from the days. It remarkably contrasts weekdays and weekends, highlights public holiday, and presents other known seasons like school vacations, all of which have influence over the turn-outs in the office. The calendar-based heatmap was implemented in a couple of R packages: \pkg{ggTimeSeries} [@R-ggTimeSeries] and \pkg{ggcal} [@R-ggcal]. However, these techniques are too constrained to colour-encoding graphics and day of week considered as the smallest time window. Time of day, which serves as one of the most important aspect in explaining variations arising from pedestrian sensor data, will be neglected through daily aggregation. Additionally if simply using colours encoded as quantities, it may becomes less perceivable of the actual variations or behaviours from the viewer's perspective.

We propose a new algorithm via linear algebra tools to go beyond the calendar-based heatmap. The approach is developed with these conditions in mind: (1) to make time of day present in addition to the existing temporal components such as day of week and day of year, (2) to add line graphs along with other types of glyphs to the visual toolkit, (3) to enable an overlaying plot consisting of multiple time series. The proposed algorithm has been implemented as the \code{frame_calendar} function in the \pkg{sugrrants} package [@R-sugrrants] using \proglang{R} [@R-base].

The remainder of the paper is organised as follows. Section \ref{sec:algorithm} describes the \code{frame_calendar} function and the detailed construction. Section \ref{sec:examples} presents some examples of its usage. Section \ref{sec:discussion} discusses the advantages and disadvantages of the method.

# Construction 
\label{sec:algorithm}

In the section, the algorithms to construct calendar grids, different scales, and reference lines and labels are discussed in detail.

```
frame_calendar(
  data, x, y, date, calendar = "monthly", dir = "h", sunday = FALSE, 
  nrow = NULL, ncol = NULL, polar = FALSE, scale = "fixed"
)
```

## Grid construction

The algorithm for constructing a calendar plot uses linear algebra, similar to that used in the glyph map displays for spatio-temporal data [@Wickham2012glyph]. To make a year long calendar, requires cells for days, embedded in blocks corresponding to months, organised into a grid layout for a year. Each month can be captured with 35 (5 $\times$ 7) cells, where the top left is Monday of week 1, and the bottom right is Sunday of week 5. These cells provide a micro canvas on which to plot the data. The first day of the month could be any of Monday-Sunday, which is determined by the year of the calendar. Months are of different length days, ranging form 28-31, and each month could extend over six weeks but the convention in these months is to wrap the last few days up to the top row of the block. The notation for creating these cells is as follows: 

* $k = 1, \dots , 7$ is the day of the week that is the first day of the month
* $d = 28, 29, 30$ or $31$ representing the number of days in any month
* $(i, j)$ is the grid position where $1 \le i \le 5$ is week within the month, $1 \le j \le 7$, is day of the week. 
* $g = k, \dots,(k+d)$ indexes the day in the month, inside the 35 possible cells

The grid position for any day in the month is given by

\begin{equation}
  \begin{aligned}
  i &= \lceil (g \mod 35) / 7\rceil, \\
  j &= g \mod 7. \label{eq:grid}
  \end{aligned}
\end{equation}

Figure \ref{fig:month-diagram} illustrates this $(i,j)$ layout for a month where $k=5$. 

```{r month-diagram, out.width = "360pt", out.height = "250pt", fig.cap = "Illustration of the indexing layout for cells in a month."}
include_graphics("figure/month.pdf")
```

To create the layout for a full year, $(m, n)$ denotes the position of the month arranged in the plot, where $1 \le m \le M$ and $1 \le n \le N$. Between each month requires some small amount of white space, label this $b$. Figure \ref{fig:year-diagram} illustrates this  layout.

```{r year-diagram, out.width = "360pt", out.height = "250pt", fig.cap = "Illustration of the indexing layout for months of one year."}
include_graphics("figure/year.pdf")
```

Each cell forms a canvas on which to draw the data. Consider the canvas to have limits $[0, 1]$ horizontally and vertically. For the pedestrian sensor data, within each cell hour is plotted horizontally and count is plotted vertically. Each variable is scaled to have values between $[0,1]$, using the minimum and maximum of all the data values to be displayed. Let $h$ be the scaled hour, and $c$ the scaled count. 

Then the final points for making the calendar line plots of the pedestrian sensor data is given by:

\begin{equation}
  \begin{aligned}
  x &= i + (i - 1) \times m + (m - 1) \times b + h, \\
  y &= -j - (j - 1) \times n - (n - 1) \times b + c. \label{eq:final}
  \end{aligned}
\end{equation}

Note that for the vertical direction, the top left is the starting point of the grid, hence the subtractions, and resulting negative values to lay out the cells. Within each cell, the starting position is bottom left. 

The algorithm can be extended relatively easily to layout from one single month to multiple years depending on the time span to be visualised. The month-by-month arrangement can be determined by the user's choice through $M$ and $N$. If one would like to compare and contrast January, February and so on across multiple years, $M = 12$ and $N$ depending on the number of years could be setup.

Monthly calendar format provides an effective layout to emphasise differences between weekdays and weekends as well as day of year (for example, public holiday) simultaneously, however, either one of which is sufficient in certain visualisation applications. If there is apparent depiction of weekday effects but none of yearly effects, weekly calendar format (weeks of a year) could be considered employing; otherwise days of a month could be laid out for standing-out yearly behaviours.

(MAKE TWO DIAGRAMS ON WEEKLY AND DAILY CALENDAR FORMATS IN KEYNOTE). Weekly and daily calendar formats are the simplifications of monthly calendar.

We only illustrate that calendar grids are laid out on the horizontal direction. The vertical direction can be enabled by swapping $i$ and $j$ in the algorithm stated above. It is useful for users in some countries where they get used to calendars of vertical organisation and other possible comparisons like Mondays across the columns rather than rows.

## Scales

One of the advantages using glyphs over heatmaps is evident in easily enabling scales on different temporal scales. All of the line glyphs shown above are drawn on the global scale so that it makes the magnitudes comparable over all the period. On the other hand, some sub-series of small magnitudes yet worth-noting shapes possibly become invisible whilst embedded in the overall picture. The individual scale or something else, as a result, complements the calendar-based visualisation in general.

There are other three types of scales in addition to the global scale: individual scales regardless of days, conditional on weekdays, and conditional on days of a month.

## Reference lines and labels

It can be noted that reference lines separating each cell and panel and labels indicating weekday and month are also constructed in order to make calendar-based graphics more accessible and informative. 

Regarding the monthly calendar format, the major reference lines separate every month panel and the minor ones separate every day cell, represented by the think and thin lines respectively. The major reference lines are placed on the far left and right as well as the bottom and top of every month panel: for each $m$, the vertical lines are determined by $\min{(x)}$ and $\max{(x)}$; for each $n$, the horizontal lines are computed by $\min{(y)}$ and $\max{(y)}$. The minor reference lines are placed on the initial positions: for each $i$, the vertical line is $\min{(x)}$; for each $j$, the horizontal line is $\min{(y)}$.

The abbreviated month labels located on the top left are obtained through $(\min{(x)}, \max{(y)})$ for every $m$ and $n$. The weekday texts with a single letter are uniformly placed on the bottom of the whole canvas, that is $\min{(y)}$.

# Examples
\label{sec:examples}

# Discussion
\label{sec:discussion}

The calendar-based visualisation provides data plots in the familiar (at least for the Western world) format of an everyday tool. Special events for the region, like Anzac Day in Australia, or Thanksgiving Day in the USA, more easily pop out to the viewer as public holidays, rather than a typical work day. 

This sort of layout may be useful for studying consumer trends, or human behaviour, like the pedestrian patterns. It may not work so well for physical patterns like temperature, which are not typically affected by human activity.

The limitation is also evident: hard to perceive trend as not on the common scale.

We shall enable interactivity in the calendar-based graphics for time series data. It will allow users to transform different temporal components and switch displays between overlaying and faceting through key strokes or mouse clicks.

```{r write-bib}
write_bib(c( .packages()), 'packages.bib')
```
